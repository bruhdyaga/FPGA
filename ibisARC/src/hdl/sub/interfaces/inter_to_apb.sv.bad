module inter_to_apb
#(
    parameter BASEADDR   = 0,
    parameter APB_ADDR_WIDTH = 30,
    parameter INT_ADDR_WIDTH = 30
)
(
    intbus_interf.slave int_bus,
    apb_interface.master apb_bus
);

if(APB_ADDR_WIDTH > INT_ADDR_WIDTH) begin
    $error("APB_ADDR_WIDTH(%d bits) > INT_ADDR_WIDTH(%d bits)!",APB_ADDR_WIDTH,INT_ADDR_WIDTH);
end

if(INT_ADDR_WIDTH > 32) begin
    $error("INT_ADDR_WIDTH(%d bits) more than 32 bits!",APB_ADDR_WIDTH,INT_ADDR_WIDTH);
end

localparam EXT_WIDTH = INT_ADDR_WIDTH - APB_ADDR_WIDTH; // количество старших бит шины int неразмеченных в apb
localparam ADDR_MASK = 32'hFFFFFFFF & (~(2**EXT_WIDTH)); // маска на действующую часть шины apb

assign addr_map = (INT_ADDR_WIDTH & ADDR_MASK) == BASEADDR; // адрес мастершины в области apb; 0 или 1

assign apb_bus.clk    = int_bus.clk;
assign apb_bus.resetn = int_bus.resetn;

always_ff@(posedge apb_bus.clk or negedge apb_bus.resetn)
if(apb_bus.resetn == '0) begin
    apb_bus.paddr <= '0;
end else begin
    apb_bus.paddr <= int_bus.addr[APB_ADDR_WIDTH-1:0];
end

// assign apb_bus.penable  = int_bus.wr & int_bus.rd & addr_map;
assign apb_bus.  = int_bus.;
assign apb_bus.  = int_bus.;
assign apb_bus.  = int_bus.;
assign apb_bus.  = int_bus.;
assign apb_bus.  = int_bus.;
assign apb_bus.  = int_bus.;
assign apb_bus.  = int_bus.;

// apb
// logic [ADDR_WIDTH-1:0] paddr;
// logic        penable;
logic [31:0] prdata;
logic        pready;
logic        psel;
logic        pslverr;
logic [31:0] pwdata;
logic        pwrite;

// intbus
// logic                      clk;        // Bus (CPU) clock
// logic                      resetn;     // Reset
// logic [ADDR_WIDTH - 1 : 0] addr;       // Address bus
logic [DATA_WIDTH - 1 : 0] wdata;      // Write data bus
logic [DATA_WIDTH - 1 : 0] rdata;      // Read data bus
logic                      rvalid;     // Read valid
logic                      wr;         // Write enable flag
logic                      rd;         // Read enable flag



endmodule